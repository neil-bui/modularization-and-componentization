{"ast":null,"code":"// Adapted from:\n// https://github.com/mrdoob/three.js/blob/dev/src/geometries/CylinderGeometry.js\n// @author mrdoob / http://mrdoob.com/\n// @author Mugen87 / https://github.com/Mugen87\n// The MIT License\n// Copyright Â© 2010-2019 three.js authors\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n// radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2\nexport default function cylinderGeometry() {\n  var radiusTop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  var radiusBottom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var radialSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 8;\n  var heightSegments = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n  var openEnded = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var thetaStart = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n  var thetaLength = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : Math.PI * 2;\n  var rSegments = Math.floor(radialSegments || 8);\n  var hSegments = Math.floor(heightSegments || 1);\n  var indices = [];\n  var vertices = [];\n  var normals = [];\n  var uvs = [];\n  var index = 0;\n  var indexArray = [];\n  var halfHeight = height / 2;\n  generateTorso();\n\n  if (openEnded === false) {\n    if (radiusTop > 0) generateCap(true);\n    if (radiusBottom > 0) generateCap(false);\n  }\n\n  function generateTorso() {\n    var x, y;\n    var normal = new Array(3);\n    var vertex = new Array(3);\n    var slope = (radiusBottom - radiusTop) / height;\n\n    for (y = 0; y <= hSegments; y++) {\n      var indexRow = [];\n      var v = y / hSegments;\n      var radius = v * (radiusBottom - radiusTop) + radiusTop;\n\n      for (x = 0; x <= rSegments; x++) {\n        var u = x / rSegments;\n        var theta = u * thetaLength + thetaStart;\n        var sinTheta = Math.sin(theta);\n        var cosTheta = Math.cos(theta);\n        vertex[0] = radius * sinTheta;\n        vertex[1] = -v * height + halfHeight;\n        vertex[2] = radius * cosTheta;\n        vertices.push.apply(vertices, vertex);\n        normal[0] = sinTheta;\n        normal[1] = slope;\n        normal[2] = cosTheta;\n        var len = Math.sqrt(normal[0] * normal[0] + normal[1] * normal[1] + normal[2] * normal[2]);\n        normal[0] *= 1 / (len || 1);\n        normal[1] *= 1 / (len || 1);\n        normal[2] *= 1 / (len || 1);\n        normals.push.apply(normals, normal);\n        uvs.push(u, 1 - v);\n        indexRow.push(index++);\n      }\n\n      indexArray.push(indexRow);\n    }\n\n    for (x = 0; x < rSegments; x++) {\n      for (y = 0; y < hSegments; y++) {\n        var a = indexArray[y][x];\n        var b = indexArray[y + 1][x];\n        var c = indexArray[y + 1][x + 1];\n        var d = indexArray[y][x + 1];\n        indices.push(a, b, d);\n        indices.push(b, c, d);\n      }\n    }\n  }\n\n  function generateCap(top) {\n    var x, centerIndexStart, centerIndexEnd;\n    var uv = new Array(2);\n    var vertex = new Array(3);\n    var radius = top === true ? radiusTop : radiusBottom;\n    var sign = top === true ? 1 : -1;\n    centerIndexStart = index;\n\n    for (x = 1; x <= rSegments; x++) {\n      vertices.push(0, halfHeight * sign, 0);\n      normals.push(0, sign, 0);\n      uvs.push(0.5, 0.5);\n      index++;\n    }\n\n    centerIndexEnd = index;\n\n    for (x = 0; x <= rSegments; x++) {\n      var u = x / rSegments;\n      var theta = u * thetaLength + thetaStart;\n      var cosTheta = Math.cos(theta);\n      var sinTheta = Math.sin(theta);\n      vertex[0] = radius * sinTheta;\n      vertex[1] = halfHeight * sign;\n      vertex[2] = radius * cosTheta;\n      vertices.push.apply(vertices, vertex);\n      normals.push(0, sign, 0);\n      uv[0] = cosTheta * 0.5 + 0.5;\n      uv[1] = sinTheta * 0.5 * sign + 0.5;\n      uvs.push.apply(uvs, uv);\n      index++;\n    }\n\n    for (x = 0; x < rSegments; x++) {\n      var c = centerIndexStart + x;\n      var i = centerIndexEnd + x;\n\n      if (top === true) {\n        indices.push(i, i + 1, c);\n      } else {\n        indices.push(i + 1, i, c);\n      }\n    }\n  }\n\n  return {\n    indices: indices,\n    vertices: vertices,\n    normals: normals,\n    uvs: uvs\n  };\n}","map":null,"metadata":{},"sourceType":"module"}