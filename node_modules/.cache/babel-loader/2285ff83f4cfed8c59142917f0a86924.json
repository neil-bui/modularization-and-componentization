{"ast":null,"code":"import { useEffect, useMemo } from 'react';\nimport warn from 'warning';\nvar prefix = 'react-vertex:';\nexport function useTypedArray(data, format) {\n  var memoized = useMemo(function () {\n    var contents;\n\n    if (format && typeof format === 'string') {\n      switch (format.toUpperCase()) {\n        case 'U8':\n          contents = Uint8Array.from(data);\n          break;\n\n        case 'U16':\n          contents = Uint16Array.from(data);\n          break;\n\n        case 'U32':\n          contents = Uint32Array.from(data);\n          break;\n\n        case 'I8':\n          contents = Int8Array.from(data);\n          break;\n\n        case 'I16':\n          contents = Int16Array.from(data);\n          break;\n\n        case 'I32':\n          contents = Int32Array.from(data);\n          break;\n\n        case 'F32':\n          contents = Float32Array.from(data);\n          break;\n      }\n    }\n\n    if (!contents) {\n      if (data instanceof Uint8Array || data instanceof Uint16Array || data instanceof Uint32Array || data instanceof Int8Array || data instanceof Int16Array || data instanceof Int32Array || data instanceof Float32Array) {\n        return data;\n      } else {\n        throw Error('Undable to return typed array instance.');\n      }\n    }\n\n    return contents;\n  }, [data, format]);\n  return memoized;\n}\nexport function useBuffer(gl, data) {\n  var isIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var format = arguments.length > 3 ? arguments[3] : undefined;\n  var usage = arguments.length > 4 ? arguments[4] : undefined;\n  var contents = useTypedArray(data, format);\n  var memoized = useMemo(function () {\n    var buffer = gl.createBuffer();\n    warn(!!buffer, \"\".concat(prefix, \" Failed to create buffer.\"));\n    return buffer;\n  }, [gl]);\n  useMemo(function () {\n    if (isIndex) {\n      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, memoized);\n      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, contents, usage);\n      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    } else {\n      gl.bindBuffer(gl.ARRAY_BUFFER, memoized);\n      gl.bufferData(gl.ARRAY_BUFFER, contents, usage);\n      gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    }\n  }, [gl, isIndex, usage, contents, memoized]);\n  useEffect(function () {\n    return function () {\n      gl.isBuffer(memoized) && gl.deleteBuffer(memoized);\n    };\n  }, [gl, memoized]);\n  return memoized;\n}\nexport function useStaticBuffer(gl, data) {\n  var isIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var format = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  return useBuffer(gl, data, isIndex, format, gl.STATIC_DRAW);\n}\nexport function useStreamBuffer(gl, data) {\n  var isIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var format = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  return useBuffer(gl, data, isIndex, format, gl.STREAM_DRAW);\n}\nexport function useDyanmicBuffer(gl, data) {\n  var isIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var format = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  return useBuffer(gl, data, isIndex, format, gl.DYNAMIC_DRAW);\n}","map":null,"metadata":{},"sourceType":"module"}