{"ast":null,"code":"import _typeof from \"@babel/runtime/helpers/typeof\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport React, { Component, createRef } from 'react';\nimport ReactVertexReconciler, { SceneNode } from './Reconciler';\nimport ReactVertexContext from './Context';\n\nvar Canvas = /*#__PURE__*/function (_Component) {\n  _inherits(Canvas, _Component);\n\n  var _super = _createSuper(Canvas);\n\n  function Canvas() {\n    var _this;\n\n    _classCallCheck(this, Canvas);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n    _this.sceneNode = void 0;\n    _this.state = {\n      error: false,\n      message: ''\n    };\n    _this.canvas = /*#__PURE__*/createRef();\n    _this.container = void 0;\n    _this.contextObject = void 0;\n\n    _this.renderScene = function () {\n      if (_this.sceneNode) {\n        _this.sceneNode.render();\n      }\n    };\n\n    return _this;\n  }\n\n  _createClass(Canvas, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var current = this.canvas.current;\n      var _this$props = this.props,\n          _this$props$webgl = _this$props.webgl1,\n          webgl1 = _this$props$webgl === void 0 ? true : _this$props$webgl,\n          _this$props$webgl2 = _this$props.webgl2,\n          webgl2 = _this$props$webgl2 === void 0 ? false : _this$props$webgl2,\n          _this$props$clearColo = _this$props.clearColor,\n          clearColor = _this$props$clearColo === void 0 ? [0, 0, 0, 1] : _this$props$clearColo,\n          children = _this$props.children,\n          _this$props$antialias = _this$props.antialias,\n          antialias = _this$props$antialias === void 0 ? false : _this$props$antialias,\n          _this$props$textureFl = _this$props.textureFlip,\n          textureFlip = _this$props$textureFl === void 0 ? true : _this$props$textureFl,\n          _this$props$contextAt = _this$props.contextAttrs,\n          contextAttrs = _this$props$contextAt === void 0 ? {} : _this$props$contextAt,\n          _this$props$extension = _this$props.extensions,\n          extensions = _this$props$extension === void 0 ? [] : _this$props$extension,\n          _this$props$renderOnU = _this$props.renderOnUpdate,\n          renderOnUpdate = _this$props$renderOnU === void 0 ? false : _this$props$renderOnU;\n\n      var attrs = _objectSpread({\n        antialias: antialias\n      }, contextAttrs);\n\n      if (!current) {\n        return;\n      }\n\n      var gl, webglVersion;\n\n      if (webgl2) {\n        gl = current.getContext('webgl2', attrs);\n        webglVersion = 2;\n      }\n\n      if (!gl && webgl1) {\n        gl = current.getContext('webgl', attrs);\n        webglVersion = 1;\n      }\n\n      if (!gl) {\n        this.setState({\n          error: true,\n          message: 'Could not create WebGL context.'\n        });\n        return;\n      }\n\n      textureFlip && gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n      this.sceneNode = new SceneNode(current, extensions, gl);\n\n      if (typeof webglVersion === 'number') {\n        this.sceneNode.webglVersion = webglVersion;\n      }\n\n      this.sceneNode.clearColor = clearColor;\n      this.sceneNode.renderOnUpdate = renderOnUpdate;\n\n      if ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === 'object') {\n        // @ts-ignore\n        window.sceneNode = this.sceneNode;\n      }\n\n      var update = this.updateDimensions();\n\n      if (update) {\n        this.contextObject = {\n          scene: this.sceneNode,\n          width: update.width,\n          height: update.height\n        };\n      }\n\n      this.container = ReactVertexReconciler.createContainer(this.sceneNode, false, false);\n\n      if (this.contextObject) {\n        ReactVertexReconciler.updateContainer( /*#__PURE__*/React.createElement(ReactVertexContext.Provider, {\n          value: this.contextObject\n        }, children), this.container, this, function () {});\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      var children = this.props.children;\n      var dims = this.updateDimensions();\n\n      if (dims && dims.update && this.contextObject) {\n        this.contextObject = _objectSpread(_objectSpread({}, this.contextObject), {}, {\n          width: dims.width,\n          height: dims.height\n        });\n      }\n\n      if (this.container && this.contextObject) {\n        ReactVertexReconciler.updateContainer( /*#__PURE__*/React.createElement(ReactVertexContext.Provider, {\n          value: this.contextObject\n        }, children), this.container, this, function () {});\n      }\n    }\n  }, {\n    key: \"updateDimensions\",\n    value: function updateDimensions() {\n      var current = this.canvas.current;\n\n      if (!current) {\n        return;\n      }\n\n      var _this$props2 = this.props,\n          width = _this$props2.width,\n          height = _this$props2.height,\n          renderOnResize = _this$props2.renderOnResize;\n      var devicePixelRatio = window.devicePixelRatio || 1;\n      var nextWidth = Math.round(width * devicePixelRatio);\n      var nextHeight = Math.round(height * devicePixelRatio);\n      var update = nextWidth !== current.width || nextHeight !== current.height;\n\n      if (update) {\n        current.style.width = \"\".concat(width, \"px\");\n        current.style.height = \"\".concat(height, \"px\");\n        current.width = nextWidth;\n        current.height = nextHeight;\n        renderOnResize && this.sceneNode && this.sceneNode.requestRender();\n      }\n\n      return {\n        width: nextWidth,\n        height: nextHeight,\n        update: update\n      };\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.container) {\n        ReactVertexReconciler.updateContainer(null, this.container, this, function () {});\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props3 = this.props,\n          _this$props3$canvasCl = _this$props3.canvasClass,\n          canvasClass = _this$props3$canvasCl === void 0 ? '' : _this$props3$canvasCl,\n          _this$props3$canvasSt = _this$props3.canvasStyle,\n          canvasStyle = _this$props3$canvasSt === void 0 ? {} : _this$props3$canvasSt;\n      return /*#__PURE__*/React.createElement(\"canvas\", {\n        ref: this.canvas,\n        className: canvasClass,\n        style: canvasStyle\n      });\n    }\n  }]);\n\n  return Canvas;\n}(Component);\n\nexport { Canvas as default };","map":null,"metadata":{},"sourceType":"module"}