{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport throttle from 'lodash.throttle';\nimport warn from 'warning';\nimport Node from './GraphNode';\nimport { instancedExt, MaterialNode } from '.';\nimport { PointLights } from '../lights';\nimport { CameraNode } from './CameraNode';\nimport { GeometryNode } from './GeometryNode';\nimport { InstancedNode } from './InstancedNode';\nexport var isSceneNode = Symbol('isSceneNode');\n\nfunction getMode(gl, modeString) {\n  if (!modeString) {\n    return gl.TRIANGLES;\n  }\n\n  switch (modeString) {\n    case 'TRIANGLES':\n      return gl.TRIANGLES;\n\n    case 'LINES':\n      return gl.LINES;\n\n    case 'POINTS':\n      return gl.POINTS;\n\n    case 'LINE_STRIP':\n      return gl.LINE_STRIP;\n\n    case 'LINE_LOOP':\n      return gl.LINE_LOOP;\n\n    case 'TRIANGLE_STRIP':\n      return gl.TRIANGLE_STRIP;\n\n    case 'TRIANGLE_FAN':\n      return gl.TRIANGLE_FAN;\n\n    default:\n      return gl.TRIANGLES;\n  }\n}\n\nexport var SceneNode = /*#__PURE__*/function (_Node) {\n  _inherits(SceneNode, _Node);\n\n  var _super = _createSuper(SceneNode);\n\n  function SceneNode(canvas, extensions, _gl) {\n    var _this;\n\n    _classCallCheck(this, SceneNode);\n\n    _this = _super.call(this);\n    _this.context = void 0;\n    _this.element = void 0;\n    _this.maxTextures = void 0;\n    _this.extensions = void 0;\n    _this[isSceneNode] = true;\n    _this.renderOnUpdate = false;\n    _this.webglVersion = 1;\n    _this.pointLights = new PointLights();\n    _this.clearColor = [0, 0, 0, 0];\n    _this.textureUnits = {};\n    _this.materialMap = new WeakMap();\n    _this.activeAttribCount = 0;\n    _this.activeAttributes = null;\n\n    _this.render = function () {\n      var gl = _this.context;\n      gl.enable(gl.DEPTH_TEST);\n      gl.clearColor.apply(gl, _toConsumableArray(_this.clearColor));\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n      Object.keys(_this.textureUnits).forEach(function (unit) {\n        if (_this.textureUnits[unit] !== false) {\n          /* @ts-ignore */\n          gl.activeTexture(gl[\"TEXTURE\".concat(unit)]);\n          gl.bindTexture(gl.TEXTURE_2D, _this.textureUnits[unit]);\n        }\n      });\n      var needsMatrixUpdate = _this.needsMatrixUpdate === true;\n\n      if (needsMatrixUpdate) {\n        _this.updateMatrix();\n\n        _this.updateWorldMatrix();\n\n        _this.needsMatrixUpdate = false;\n      }\n\n      for (var i = 0; i < _this.children.length; i++) {\n        _this.renderNode(_this.children[i], null, null, needsMatrixUpdate);\n      }\n    };\n\n    _this.requestRender = throttle(_this.render, 17);\n    _this.context = _gl;\n    _this.element = canvas;\n    _this.maxTextures = _gl.getParameter(_gl.MAX_TEXTURE_IMAGE_UNITS);\n    _this.extensions = extensions.reduce(function (acc, ext) {\n      acc[ext] = _gl.getExtension(ext);\n      return acc;\n    }, {});\n    return _this;\n  }\n\n  _createClass(SceneNode, [{\n    key: \"getTextureUnit\",\n    value: function getTextureUnit(texture) {\n      for (var _unit = 0; _unit < this.maxTextures; _unit++) {\n        if (this.textureUnits[_unit] === undefined) {\n          this.textureUnits[_unit] = texture || false;\n          return _unit;\n        }\n      }\n\n      warn(false, \"Max textures(\".concat(this.maxTextures, \") exceeded.\"));\n      return this.maxTextures - 1;\n    }\n  }, {\n    key: \"releaseTextureUnit\",\n    value: function releaseTextureUnit(unit) {\n      delete this.textureUnits[unit];\n    }\n  }, {\n    key: \"setMaterial\",\n    value: function setMaterial(gl, _ref) {\n      var program = _ref.program;\n\n      if (!program) {\n        throw Error('Encountered material with no program.');\n      }\n\n      var material = this.materialMap.get(program);\n\n      if (material) {\n        return material;\n      }\n\n      var attributes = {};\n      var attribCount = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n\n      for (var i = attribCount - 1; i >= 0; i--) {\n        var attr = gl.getActiveAttrib(program, i);\n\n        if (attr) {\n          attributes[attr.name] = gl.getAttribLocation(program, attr.name);\n        } else {\n          warn(false, 'Encountered invalid attribute index.');\n        }\n      }\n\n      var uniforms = {\n        v: gl.getUniformLocation(program, 'viewMatrix'),\n        m: gl.getUniformLocation(program, 'modelMatrix'),\n        p: gl.getUniformLocation(program, 'projectionMatrix')\n      };\n      material = {\n        program: program,\n        uniforms: uniforms,\n        attributes: attributes,\n        attribCount: attribCount\n      };\n      this.materialMap.set(program, material);\n      return material;\n    }\n  }, {\n    key: \"renderNode\",\n    value: function renderNode(node, activeCamera, activeMaterial, needsMatrixUpdate) {\n      var gl = this.context; // *************************************************\n      // UPDATE MATRIX IF NEEDED\n      // *************************************************\n\n      needsMatrixUpdate = needsMatrixUpdate || node.needsMatrixUpdate === true;\n\n      if (needsMatrixUpdate) {\n        node.updateMatrix();\n        node.updateWorldMatrix();\n        node.needsMatrixUpdate = false;\n      } // *************************************************\n      // HANDLE CAMERA\n      // *************************************************\n\n\n      if (node instanceof CameraNode) {\n        activeCamera = node;\n      } // *************************************************\n      // HANDLE MATERIAL\n      // *************************************************\n\n\n      if (node instanceof MaterialNode) {\n        var nextMaterial = this.setMaterial(gl, node); // note: buffers are deleted when no longer in use by the buffer\n        // hooks. So we to disable attribute indexes no longer in use or it\n        // will throw an error about no buffer being bound to the index.\n\n        var diff = this.activeAttribCount - nextMaterial.attribCount;\n\n        if (diff > 0) {\n          for (var i = 0; i < diff; i++) {\n            gl.disableVertexAttribArray(nextMaterial.attribCount + i);\n          }\n        }\n\n        this.activeAttribCount = nextMaterial.attribCount;\n        this.activeAttributes = null;\n        activeMaterial = nextMaterial;\n        gl.useProgram(activeMaterial.program);\n\n        if (activeCamera) {\n          var _activeCamera = activeCamera,\n              view = _activeCamera.view,\n              projection = _activeCamera.projection;\n          gl.uniformMatrix4fv(activeMaterial.uniforms.v, false, view);\n          gl.uniformMatrix4fv(activeMaterial.uniforms.p, false, projection);\n        }\n      } // *************************************************\n      // HANDLE GEOMETRY\n      // *************************************************\n\n\n      if (node instanceof GeometryNode) {\n        if (activeMaterial) {\n          gl.useProgram(activeMaterial.program);\n\n          if (node.attributes !== this.activeAttributes) {\n            for (var attr in activeMaterial.attributes) {\n              var location = activeMaterial.attributes[attr];\n              node.attributes[attr](location);\n            }\n\n            this.activeAttributes = node.attributes;\n          }\n\n          gl.uniformMatrix4fv(activeMaterial.uniforms.m, false, node.worldMatrix);\n\n          if (node.drawArrays) {\n            gl.drawArrays(getMode(gl, node.drawArrays.mode), node.drawArrays.first || 0, node.drawArrays.count);\n          } else if (node.drawElements) {\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, node.index);\n            gl.drawElements(getMode(gl, node.drawElements.mode), node.drawElements.count, node.drawElements.type ? // @ts-ignore\n            gl[node.drawElements.type] : gl.UNSIGNED_SHORT, node.drawElements.offset || 0);\n          }\n\n          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n          gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        }\n      } // *************************************************\n      // HANDLE INSTANCED GEOMETRY\n      // *************************************************\n\n\n      if (node instanceof InstancedNode) {\n        if (activeMaterial) {\n          gl.useProgram(activeMaterial.program);\n\n          if (this.extensions[instancedExt] === undefined) {\n            this.extensions[instancedExt] = gl.getExtension(instancedExt);\n          }\n\n          var ext = this.extensions[instancedExt];\n\n          if (node.attributes !== this.activeAttributes) {\n            for (var _attr in activeMaterial.attributes) {\n              var _location = activeMaterial.attributes[_attr];\n\n              node.attributes[_attr](_location, ext, this.webglVersion);\n            }\n\n            this.activeAttributes = node.attributes;\n          }\n\n          gl.uniformMatrix4fv(activeMaterial.uniforms.m, false, node.worldMatrix);\n          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, node.index);\n\n          if (this.webglVersion === 2 && node.drawElements) {\n            // @ts-ignore\n            gl.drawElementsInstanced(getMode(gl, node.drawElements.mode), node.drawElements.count, node.drawElements.type ? // @ts-ignore\n            gl[node.drawElements.type] : gl.UNSIGNED_SHORT, node.drawElements.offset || 0, node.drawElements.primcount);\n          } else if (node.drawElements) {\n            ext.drawElementsInstancedANGLE(getMode(gl, node.drawElements.mode), node.drawElements.count, node.drawElements.type ? // @ts-ignore\n            gl[node.drawElements.type] : gl.UNSIGNED_SHORT, node.drawElements.offset || 0, node.drawElements.primcount);\n          }\n\n          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n          gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        }\n      }\n\n      for (var _i = 0; _i < node.children.length; _i++) {\n        this.renderNode(node.children[_i], activeCamera, activeMaterial, needsMatrixUpdate);\n      }\n    }\n  }]);\n\n  return SceneNode;\n}(Node);","map":null,"metadata":{},"sourceType":"module"}